The Hacker's Guide to libIRC
============================

Please read this document if you are contributing to libIRC.

For the sake of code consistency and long-term evolution of libIRC,
there are guidelines for getting involved.  Developers are strongly
encouraged to follow these guidelines.  There are simply too many
religious wars over what usually come down to personal preferences and
familiarity that are distractions from making productive progress.


TABLE OF CONTENTS
-----------------
  Introduction
  Table of Contents
  Getting Started
  Source Code Languages
  Filesystem Organization
  Coding Style
  Documentation
  Testing
  Patch Submission Guidelines
  Bugs
  Commit Access
  Version Numbers & Compatibility
  Making a Release
  Getting Help


GETTING STARTED
---------------

As there are many ways to get started with libIRC, one of the most
important steps for new developers to do is get involved in the
discussions and communicate with the libIRC developers.  There are
mailing lists, on-line forums, and core developers available via IRC.
Developers are encouraged to participate in any or all of them.

* E-mail Mailing Lists

  Go to http://sf.net/projects/libirc/ and join the "libirc-devel"
  mailing list.  More involved developers will also want to join the
  "libirc-commits" list.

* On-line Forum

  Discussion forums are available at http://sf.net/projects/libirc/
  under the forums section.  Of particular interest to developers is,
  of course, the Developers forum.

* Internet Relay Chat

  The primary and generally preferred mechanism for interactive
  developer discussions is via IRC. The project maintains an IRC
  channel on the Freenode network (#libIRC). Several of the core developers
  and users of libIRC hang out there.  With most any irc client you should 
  be able to join #libIRC on irc.freenode.net, port 6667.  See
  http://brlcad.org/irc/ and http://irchelp.org for more information.

To contribute source code to libIRC, begin by submiting source code
patches to the patches section at http://sf.net/projects/libirc/.
Patches in the universal diff format (diff -u) are preferred.


SOURCE CODE LANGUAGES
---------------------

The libIRC library core is written in C++ with a binding library made
available in C.  Bindings for other languages are always more than
welcome.


FILESYSTEM ORGANIZATION
-----------------------

Here is an incomprehensive sample of how some of the sources are
organized in the source distribution:

src/
	The bulk of the source code

include/
	The public headers

tests/
	Tests and example code

misc/
	Various project and build scripts and resources


CODING STYLE
------------

For anyone who plans on contributing code, the following conventions
should be followed.  Contributions that do not conform will be
rediculed and rejected until they do.

Code Organization:

Header files private to a library go into that library's directory.
Public header files go intp the include/ directory on the top level.
Public header files should not include any headers that are private.

C++ files use the .cpp extension.  C files use the .c extension.
Header files use the .h extension.

GNU Build System:

Autconf checks should be used extensively to test for availability of
system services such as standard header files, available libraries,
and data types.  No assumptions should be made regarding the
availability of any particular header, function, datatype, or other
resource.  After running the configure script, there will be an
autogenerated include/config.h file that contains many preprocessor
directives and type declarations that may be used where needed.  For
the Windows platform, this file will be generated and maintained
manually.

Generic platform checks (e.g. ifdef unix) are highly discouraged and
should not be used.  Replace those checks with tests for the actual
facility being utilized instead.

Coding Standards:

Features of C++ that that conform to the INCITS/ISO/IEC 14882:2003 C++
standards are generally the baseline for strict language conformance
for C++ files.  Features of C that conform to the ISO/IEC 9899-1999 C
standard (C99) are generally the baseline for strict language
conformance for C files.  Particulars of the usage of those languages
still requires special attention to the following guidelines:

globals are discouraged - globals are often the easy way around a hard
coding problem, try to find another solution unless there is a good
reason.

Code Formatting Conventions:

The code should strive to achieve conformance with the GNU coding
standard with a few exceptions, omissions, and reminders listed below.
The following should be more strictly adhered to, if only for the sake
of being consistent.

1) Whitespace

Indents are 2 characters, tabs are 8 characters.  There should be an
emacs and vi setting at the end of each file to adopt, enforce, and
remind this convention.  The following lines should be in all source
and header files at the end of the file:

// Local Variables: ***
// mode: C++ ***
// tab-width: 8 ***
// c-basic-offset: 2 ***
// indent-tabs-mode: t ***
// End: ***
// ex: shiftwidth=2 tabstop=8

Space around operators.
  a = (b + c) * d;  /* ok */

No space around parentheses.
  while (1) { ...   /* ok */

Commas and semicolons are followed by whitespace.
  int main(int argc, char *argv[]); /* ok */
  for (i = 0; i < max; i++) { ...   /* ok */

2) Braces

Opening braces should be on the same line as their statement, close
braces should line up with that same statement.
  for (i = 0; i < 100; i++) {
    if (i % 10 == 0) {
      j += 1;
    } else {
      j -= 1;
    }
  }
      
3) Names

Prefer mixed-case names over underscore-separated ones. (this one is
less important, as there are vast majorities of both in the code)
Variable names should start with a lowercase letter.
  double localVariable; /* ok */
  double LocalVariable; /* bad (looks like class or constructor) */
  double _localVar;     /* bad (looks like member variable)      */

Variables are not to be "decorated" to show their type (i.e. do not
use Hungarian notation or variations thereof) with a slight exception
for pointers on occasion.  The name should use a concise, meaningful
name that is not cryptic (you typing a descriptive name is preferred
over someone else hunting down what it meant).
  char *name;    /* ok  */
  char *pName;   /* discouraged, but okay */
  char *fooPtr;  /* bad */
  char *lpszFoo; /* bad */

Constants should be all upper-case with word boundaries separated by
underscores.
  static const int MAX_READ = 2;  /* ok  */
  static const int arraySize = 8; /* bad */

4) Debugging

Compilation preprocessor defines should never change the size of structures.
  struct Foo {
  #ifdef DEBUG_CODE  // bad
    int _magic;
  #endif
  };

---

Violations of these rules in the existing code are not excuses to
follow suit.  If code is seen that doesn't conform, it may and should
be fixed.  ;-)


DOCUMENTATION
-------------

The code should be reasonably documented, this almost goes without
saying for any body of code that is to maintain longevity.
Determining just how much documentation is sufficient and how much is
too much is generally resolved over time, but it should generally be
looked at from the perspective of "If I look at this code in a couple
years from now what would help me remember or understand it better?"
and add documentation accordingly.

All public library functions and most private or application functions
should be appropriately documented using Doxygen style comments.
Without getting into the advanced details, this minimally means that
you need to add an additional asterisk to a comment that preceeds your
functions:

/** Computes the answer to the meaning of life, the universe, and
 *  everything.
 */
int everything() { return 42; };


TESTING
-------

While specific plans for unit and black box testing is not yet
finalized, the Corredor Automation Test Suite will be used to assist
in performing cross-platform build tests, regression tests, and
various integration and operability tests.

A debug build may be specified via:

./configure --enable-debug

A profile build may be specified via:

./configure --enable-profiling

Verbose compilation warnings may be enabled:

./configure --enable-warnings

To perform a run of the test suite to validate behavior:

make tests

PATCH SUBMISSION GUIDELINES
---------------------------

All patches should be submitted in the unified diff format.  This is
generally the "-u" option to diff, and is supported by the cvs diff
command:

cvs diff -u > my_patch.diff

Where possible, diffs should be generated against the latest CVS
version available to make it easier to review and patch the diff in.
If a modification involves the addition or removal of files, those
files should be provided separately with instructions on where they
belong (or what should be removed).  If CVS cannot be used, please
provide the complete release and build number of the sources you
worked with.

Patches that are difficult to apply are difficult to accept.


BUGS
----

When a bug or unexpected behavior is encountered, it needs to be
documented.  If you are a libIRC developer with commit access, this
means either making a comment in the BUGS file or by making a formal
report to the SourceForge bug tracker at:

http://sourceforge.net/tracker/?group_id=14331&atid=114331

If the bug is complicated, will require discussion, cannot be fixed
any time soon, or if you do not have CVS commit access, the issue
should be reported to the SourceForge bug tracker.  The issues listed
in BUGS are not necessarily listed in bug tracker, and vice-versa.
The BUGS files is merely maintained as a convenience notepad of long
and short term issues for the developers.


COMMIT ACCESS
-------------

CVS commit access is evaluated on a person-to-person basis at the
discretion of the existing developers.  If you'd like to have commit
access, there is usually no need to ask.  Getting involved with the
other developers and making patches will generally result in
consideration to grant CVS access over time.  Again, if you have to
ask for it, you probably won't get it.

Those with CVS commit access have a responsibility to ensure that
other developers are following the guidelines that have been described
herein within reason.  A basic rule of thumb is: don't break anything.
While the CVS HEAD is generally always expected to compile, more
flexibility is allowed for resolution of cross-platform build issues.

While the testing process will strive to ensure consistent behavior as
changes are made, the responsilibity still remains with the individual
developer to ensure that everything still compiles and runs as it
should.


VERSION NUMBERS & COMPATIBILITY
-------------------------------

The libIRC version number is contained in the configure.ac file.  The
README and NEWS files may also make references to version numbers.

The libIRC library has adopted a three-digit version number convention
for identifying and tracking future releases.  This number follows a
common convention where the three numbers represent:

	{MAJOR_VERSION}.{MINOR_VERSION}.{PATCH_VERSION}

All "development" builds use an odd number for the minor version.  All
"release" builds use an even number for the minor version.

The MAJOR_VERSION should only increment when it is deemed that a
significant amount of major changes have accumulated, new features
have been added, or enough significant backwards incompatibilities
were added to make a release warrant a major version increment.  In
general, releases that differ in the MAJOR_VERSION are not considered
compatible with each other.

The MINOR_VERSION is updated more frequently and serves the dual role
as previously mentioned of easily identifying a build as a public
release.  A minor version update is generally issued after significant
development activity (generally a month or more of activity) has been
tested and deemed sufficiently stable.  When a stable release is made,
it is tagged as a maintenance branch in cvs and patch releases are
performed on that branch.

The PATCH_VERSION may and should be updated as frequently as is
necessary.  Every public maintenance release should increment the
patch version.  Every development version modification that is
backwards incompatible in some manner should increment the patch
version number.

MAKING A RELEASE
----------------

When making a release, certain public repositories, mailing lists, and
news outlets require updating and notification.  Especially when a
major or minor version of libIRC is going to be released, it is
important to follow and ensure that the following steps have been
successfully performed:

0) All code is commited to CVS

1) NEWS includes a comment for all items added since the previous
   minor release.

2) All existing manpages are updated with the latest changes.

3) Version numbers (minimally in configure.ac and README) are updated
   appropriately (see VERSION NUMBERS & COMPATIBILITY section).

4) A "./configure && make" completes successfully on all platforms.

5) Perform a "make distcheck" successfully.  This will ensure that a
   proper source distribution tarball may be generated and that a
   non-autotools build should compile properly.

6) Tag the release using the format "rel-MAJOR-MINOR-PATCH".  See the
   doc/cvspolicy.txt document for details.  e.g. cvs tag rel-7-2-3

7) Export the tagged release "cvs export -r rel-MAJOR-MINOR-PATCH" to
   obtain a tagged version of the sources.

8) Perform a "make dist" on the exported sources to generate a source
   tarball.

9) Verify that the source tarball may be expanded; and that it builds,
   and that the file permissions are correct.

10) Use the source tarball to generate platform-specific builds.  Test
    the build.

11) Post the source and platform-specific binaries to the SourceForge
    file tracker (i.e. upload the archives via ftp to upload.sf.net).

12) Increment and commit the release number in CVS in the configure.ac
    file immediately.

13) Notify the following:

       libIRC developer mailing list
       libirc-devel@lists.sourceforge.net

       News on the libIRC website
       http://libIRC.sf.net/

       SourceForge News
       http://sf.net/projects/libIRC/

       Freshmeat
       http://freshmeat.net/projects/libIRC/

14) Sit back and enjoy a beverage for a job well done.


GETTING HELP
------------

See the GETTING STARTED section.  Basically communicate with the
developers.  There is IRC, e-mail mailing lists, and on-line forums.
